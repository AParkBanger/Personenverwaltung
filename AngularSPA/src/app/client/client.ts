/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.2.0 (NJsonSchema v10.3.4.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
import {
  mergeMap as _observableMergeMap,
  catchError as _observableCatch,
} from 'rxjs/operators';
import {
  Observable,
  throwError as _observableThrow,
  of as _observableOf,
} from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
} from '@angular/common/http';

export module client {
  export const API_BASE_URL = new InjectionToken<string>(
    'http://localhost:44326'
  );

  @Injectable()
  export class Client {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
      undefined;

    constructor(
      @Inject(HttpClient) http: HttpClient,
      @Optional() @Inject(API_BASE_URL) baseUrl?: string
    ) {
      this.http = http;
      this.baseUrl = 'https://localhost:44326';
    }

    /**
     * @return Success
     */
    apiGroupsDelete(id: number): Observable<Group> {
      let url_ = this.baseUrl + '/api/Groups/{id}';
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace('{id}', encodeURIComponent('' + id));
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
        observe: 'response',
        responseType: 'blob',
        headers: new HttpHeaders({
          Accept: 'text/plain',
        }),
      };

      return this.http
        .request('delete', url_, options_)
        .pipe(
          _observableMergeMap((response_: any) => {
            return this.processApiGroupsDelete(response_);
          })
        )
        .pipe(
          _observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
              try {
                return this.processApiGroupsDelete(<any>response_);
              } catch (e) {
                return <Observable<Group>>(<any>_observableThrow(e));
              }
            } else return <Observable<Group>>(<any>_observableThrow(response_));
          })
        );
    }

    protected processApiGroupsDelete(
      response: HttpResponseBase
    ): Observable<Group> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse
          ? response.body
          : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            let result200: any = null;
            let resultData200 =
              _responseText === ''
                ? null
                : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Group.fromJS(resultData200);
            return _observableOf(result200);
          })
        );
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            return throwException(
              'An unexpected server error occurred.',
              status,
              _responseText,
              _headers
            );
          })
        );
      }
      return _observableOf<Group>(<any>null);
    }

    /**
     * @return Success
     */
    apiGroupsGetById(id: number): Observable<Group> {
      let url_ = this.baseUrl + '/api/Groups/{id}';
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace('{id}', encodeURIComponent('' + id));
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
        observe: 'response',
        responseType: 'blob',
        headers: new HttpHeaders({
          Accept: 'text/plain',
        }),
      };

      return this.http
        .request('get', url_, options_)
        .pipe(
          _observableMergeMap((response_: any) => {
            return this.processApiGroupsGetById(response_);
          })
        )
        .pipe(
          _observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
              try {
                return this.processApiGroupsGetById(<any>response_);
              } catch (e) {
                return <Observable<Group>>(<any>_observableThrow(e));
              }
            } else return <Observable<Group>>(<any>_observableThrow(response_));
          })
        );
    }

    protected processApiGroupsGetById(
      response: HttpResponseBase
    ): Observable<Group> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse
          ? response.body
          : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            let result200: any = null;
            let resultData200 =
              _responseText === ''
                ? null
                : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Group.fromJS(resultData200);
            return _observableOf(result200);
          })
        );
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            return throwException(
              'An unexpected server error occurred.',
              status,
              _responseText,
              _headers
            );
          })
        );
      }
      return _observableOf<Group>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    apiGroupsPut(id: number, body?: Group | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/Groups/{id}';
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace('{id}', encodeURIComponent('' + id));
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: 'response',
        responseType: 'blob',
        headers: new HttpHeaders({
          'Content-Type': 'application/json',
        }),
      };

      return this.http
        .request('put', url_, options_)
        .pipe(
          _observableMergeMap((response_: any) => {
            return this.processApiGroupsPut(response_);
          })
        )
        .pipe(
          _observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
              try {
                return this.processApiGroupsPut(<any>response_);
              } catch (e) {
                return <Observable<void>>(<any>_observableThrow(e));
              }
            } else return <Observable<void>>(<any>_observableThrow(response_));
          })
        );
    }

    protected processApiGroupsPut(
      response: HttpResponseBase
    ): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse
          ? response.body
          : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            return _observableOf<void>(<any>null);
          })
        );
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            return throwException(
              'An unexpected server error occurred.',
              status,
              _responseText,
              _headers
            );
          })
        );
      }
      return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    apiGroupsGet(): Observable<Group[]> {
      let url_ = this.baseUrl + '/api/Groups';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
        observe: 'response',
        responseType: 'blob',
        headers: new HttpHeaders({
          Accept: 'text/plain',
        }),
      };

      return this.http
        .request('get', url_, options_)
        .pipe(
          _observableMergeMap((response_: any) => {
            return this.processApiGroupsGet(response_);
          })
        )
        .pipe(
          _observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
              try {
                return this.processApiGroupsGet(<any>response_);
              } catch (e) {
                return <Observable<Group[]>>(<any>_observableThrow(e));
              }
            } else
              return <Observable<Group[]>>(<any>_observableThrow(response_));
          })
        );
    }

    protected processApiGroupsGet(
      response: HttpResponseBase
    ): Observable<Group[]> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse
          ? response.body
          : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            let result200: any = null;
            let resultData200 =
              _responseText === ''
                ? null
                : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
              result200 = [] as any;
              for (let item of resultData200)
                result200!.push(Group.fromJS(item));
            }
            return _observableOf(result200);
          })
        );
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            return throwException(
              'An unexpected server error occurred.',
              status,
              _responseText,
              _headers
            );
          })
        );
      }
      return _observableOf<Group[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    apiGroupsPost(body?: Group | undefined): Observable<Group> {
      let url_ = this.baseUrl + '/api/Groups';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: 'response',
        responseType: 'blob',
        headers: new HttpHeaders({
          'Content-Type': 'application/json',
          Accept: 'text/plain',
        }),
      };

      return this.http
        .request('post', url_, options_)
        .pipe(
          _observableMergeMap((response_: any) => {
            return this.processApiGroupsPost(response_);
          })
        )
        .pipe(
          _observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
              try {
                return this.processApiGroupsPost(<any>response_);
              } catch (e) {
                return <Observable<Group>>(<any>_observableThrow(e));
              }
            } else return <Observable<Group>>(<any>_observableThrow(response_));
          })
        );
    }

    protected processApiGroupsPost(
      response: HttpResponseBase
    ): Observable<Group> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse
          ? response.body
          : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            let result200: any = null;
            let resultData200 =
              _responseText === ''
                ? null
                : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Group.fromJS(resultData200);
            return _observableOf(result200);
          })
        );
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            return throwException(
              'An unexpected server error occurred.',
              status,
              _responseText,
              _headers
            );
          })
        );
      }
      return _observableOf<Group>(<any>null);
    }

    /**
     * @return Success
     */
    apiPersonsDelete(id: number): Observable<Person> {
      let url_ = this.baseUrl + '/api/Persons/{id}';
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace('{id}', encodeURIComponent('' + id));
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
        observe: 'response',
        responseType: 'blob',
        headers: new HttpHeaders({
          Accept: 'text/plain',
        }),
      };

      return this.http
        .request('delete', url_, options_)
        .pipe(
          _observableMergeMap((response_: any) => {
            return this.processApiPersonsDelete(response_);
          })
        )
        .pipe(
          _observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
              try {
                return this.processApiPersonsDelete(<any>response_);
              } catch (e) {
                return <Observable<Person>>(<any>_observableThrow(e));
              }
            } else
              return <Observable<Person>>(<any>_observableThrow(response_));
          })
        );
    }

    protected processApiPersonsDelete(
      response: HttpResponseBase
    ): Observable<Person> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse
          ? response.body
          : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            let result200: any = null;
            let resultData200 =
              _responseText === ''
                ? null
                : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Person.fromJS(resultData200);
            return _observableOf(result200);
          })
        );
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            return throwException(
              'An unexpected server error occurred.',
              status,
              _responseText,
              _headers
            );
          })
        );
      }
      return _observableOf<Person>(<any>null);
    }

    /**
     * @return Success
     */
    apiPersonsGetById(id: number): Observable<Person> {
      let url_ = this.baseUrl + '/api/Persons/{id}';
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace('{id}', encodeURIComponent('' + id));
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
        observe: 'response',
        responseType: 'blob',
        headers: new HttpHeaders({
          Accept: 'text/plain',
        }),
      };

      return this.http
        .request('get', url_, options_)
        .pipe(
          _observableMergeMap((response_: any) => {
            return this.processApiPersonsGetById(response_);
          })
        )
        .pipe(
          _observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
              try {
                return this.processApiPersonsGetById(<any>response_);
              } catch (e) {
                return <Observable<Person>>(<any>_observableThrow(e));
              }
            } else
              return <Observable<Person>>(<any>_observableThrow(response_));
          })
        );
    }

    protected processApiPersonsGetById(
      response: HttpResponseBase
    ): Observable<Person> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse
          ? response.body
          : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            let result200: any = null;
            let resultData200 =
              _responseText === ''
                ? null
                : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Person.fromJS(resultData200);
            return _observableOf(result200);
          })
        );
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            return throwException(
              'An unexpected server error occurred.',
              status,
              _responseText,
              _headers
            );
          })
        );
      }
      return _observableOf<Person>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    apiPersonsPut(id: number, body?: Person | undefined): Observable<void> {
      let url_ = this.baseUrl + '/api/Persons/{id}';
      if (id === undefined || id === null)
        throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace('{id}', encodeURIComponent('' + id));
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: 'response',
        responseType: 'blob',
        headers: new HttpHeaders({
          'Content-Type': 'application/json',
        }),
      };

      return this.http
        .request('put', url_, options_)
        .pipe(
          _observableMergeMap((response_: any) => {
            return this.processApiPersonsPut(response_);
          })
        )
        .pipe(
          _observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
              try {
                return this.processApiPersonsPut(<any>response_);
              } catch (e) {
                return <Observable<void>>(<any>_observableThrow(e));
              }
            } else return <Observable<void>>(<any>_observableThrow(response_));
          })
        );
    }

    protected processApiPersonsPut(
      response: HttpResponseBase
    ): Observable<void> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse
          ? response.body
          : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            return _observableOf<void>(<any>null);
          })
        );
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            return throwException(
              'An unexpected server error occurred.',
              status,
              _responseText,
              _headers
            );
          })
        );
      }
      return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    apiPersonsGet(): Observable<Person[]> {
      let url_ = this.baseUrl + '/api/Persons';
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
        observe: 'response',
        responseType: 'blob',
        headers: new HttpHeaders({
          Accept: 'text/plain',
        }),
      };

      return this.http
        .request('get', url_, options_)
        .pipe(
          _observableMergeMap((response_: any) => {
            return this.processApiPersonsGet(response_);
          })
        )
        .pipe(
          _observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
              try {
                return this.processApiPersonsGet(<any>response_);
              } catch (e) {
                return <Observable<Person[]>>(<any>_observableThrow(e));
              }
            } else
              return <Observable<Person[]>>(<any>_observableThrow(response_));
          })
        );
    }

    protected processApiPersonsGet(
      response: HttpResponseBase
    ): Observable<Person[]> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse
          ? response.body
          : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            let result200: any = null;
            let resultData200 =
              _responseText === ''
                ? null
                : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
              result200 = [] as any;
              for (let item of resultData200)
                result200!.push(Person.fromJS(item));
            }
            return _observableOf(result200);
          })
        );
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            return throwException(
              'An unexpected server error occurred.',
              status,
              _responseText,
              _headers
            );
          })
        );
      }
      return _observableOf<Person[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    apiPersonsPost(body?: Person | undefined): Observable<Person> {
      let url_ = this.baseUrl + '/api/Persons';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: 'response',
        responseType: 'blob',
        headers: new HttpHeaders({
          'Content-Type': 'application/json',
          Accept: 'text/plain',
        }),
      };

      return this.http
        .request('post', url_, options_)
        .pipe(
          _observableMergeMap((response_: any) => {
            return this.processApiPersonsPost(response_);
          })
        )
        .pipe(
          _observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
              try {
                return this.processApiPersonsPost(<any>response_);
              } catch (e) {
                return <Observable<Person>>(<any>_observableThrow(e));
              }
            } else
              return <Observable<Person>>(<any>_observableThrow(response_));
          })
        );
    }

    protected processApiPersonsPost(
      response: HttpResponseBase
    ): Observable<Person> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse
          ? response.body
          : (<any>response).error instanceof Blob
          ? (<any>response).error
          : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            let result200: any = null;
            let resultData200 =
              _responseText === ''
                ? null
                : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Person.fromJS(resultData200);
            return _observableOf(result200);
          })
        );
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(
          _observableMergeMap((_responseText) => {
            return throwException(
              'An unexpected server error occurred.',
              status,
              _responseText,
              _headers
            );
          })
        );
      }
      return _observableOf<Person>(<any>null);
    }
  }

  export enum Sex {
    _1 = 1,
    _2 = 2,
    _3 = 3,
  }

  export class Person implements IPerson {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    birth?: Date;
    sex?: Sex;
    groups?: Group[] | undefined;

    constructor(data?: IPerson) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data['id'];
        this.firstName = _data['firstName'];
        this.lastName = _data['lastName'];
        this.birth = _data['birth']
          ? new Date(_data['birth'].toString())
          : <any>undefined;
        this.sex = _data['sex'];
        if (Array.isArray(_data['groups'])) {
          this.groups = [] as any;
          for (let item of _data['groups'])
            this.groups!.push(Group.fromJS(item));
        }
      }
    }

    static fromJS(data: any): Person {
      data = typeof data === 'object' ? data : {};
      let result = new Person();
      result.init(data);
      return result;
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['firstName'] = this.firstName;
      data['lastName'] = this.lastName;
      data['birth'] = this.birth ? this.birth.toISOString() : <any>undefined;
      data['sex'] = this.sex;
      if (Array.isArray(this.groups)) {
        data['groups'] = [];
        for (let item of this.groups) data['groups'].push(item.toJSON());
      }
      return data;
    }
  }

  export interface IPerson {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    birth?: Date;
    sex?: Sex;
    groups?: Group[] | undefined;
  }

  export class Group implements IGroup {
    id?: number;
    name?: string | undefined;
    persons?: Person[] | undefined;

    constructor(data?: IGroup) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data['id'];
        this.name = _data['name'];
        if (Array.isArray(_data['persons'])) {
          this.persons = [] as any;
          for (let item of _data['persons'])
            this.persons!.push(Person.fromJS(item));
        }
      }
    }

    static fromJS(data: any): Group {
      data = typeof data === 'object' ? data : {};
      let result = new Group();
      result.init(data);
      return result;
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['name'] = this.name;
      if (Array.isArray(this.persons)) {
        data['persons'] = [];
        for (let item of this.persons) data['persons'].push(item.toJSON());
      }
      return data;
    }
  }

  export interface IGroup {
    id?: number;
    name?: string | undefined;
    persons?: Person[] | undefined;
  }

  export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(
      message: string,
      status: number,
      response: string,
      headers: { [key: string]: any },
      result: any
    ) {
      super();

      this.message = message;
      this.status = status;
      this.response = response;
      this.headers = headers;
      this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
      return obj.isApiException === true;
    }
  }

  function throwException(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result?: any
  ): Observable<any> {
    if (result !== null && result !== undefined)
      return _observableThrow(result);
    else
      return _observableThrow(
        new ApiException(message, status, response, headers, null)
      );
  }

  function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
      if (!blob) {
        observer.next('');
        observer.complete();
      } else {
        let reader = new FileReader();
        reader.onload = (event) => {
          observer.next((<any>event.target).result);
          observer.complete();
        };
        reader.readAsText(blob);
      }
    });
  }
}
